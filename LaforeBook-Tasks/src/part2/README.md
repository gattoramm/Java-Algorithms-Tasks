##  Массивы

## Упражнения

1. Используйте приложение Array Workshop для вставки, поиска и удаления
элементов. Убедитесь в том, что вы полностью понимаете, как он работает. Выполните упражнение как с дубликатами, так и
без них.
2. Убедитесь в том, что вы можете заранее предсказать, какой диапазон будет выбираться приложением Ordered Workshop на
каждом шаге.
3. В массиве с нечетным количеством элементов данных нет среднего элемента. Какой элемент будет сначала проверен
алгоритмом двоичного поиска? Проверьте с помощью приложения Ordered Workshop.

### Программные проекты

1. Добавьте в класс HighArray из программы highArray.java (листинг 2.3) метод getMax(), который возвращает наибольшее
значение ключа в массиве или –1, если массив пуст. Добавьте в main() код для тестирования нового метода. Считайте, что
все ключи являются положительными числами.
2. Измените метод из пункта 2.1 так, чтобы элемент с наибольшим ключом не только возвращался методом, но и удалялся из
массива. Присвойте новой версии имя removeMax().
3. Метод removeMax() из пункта 2.2 может использоваться для сортировки содержимого массива по ключу. Реализуйте алгоритм
сортировки, который не изменяет класса HighArray (а изменяет только код main()). Вам потребуется второй массив для
хранения отсортированных данных. (Этот алгоритм представляет собой крайне примитивную разновидность сортировки методом
выбора, описанной в главе 3, «Простая сортировка».)
4. Измените программу orderedArray.java (листинг 2.4) так, чтобы методы insert() и delete(), а также метод find()
использовали двоичный поиск (как предлагается в тексте).
5. Добавьте в класс OrdArray программы orderedArray.java (листинг 2.4) метод merge(), объединяющий два упорядоченных
исходных массива в один упорядоченный приемный массив. Включите в main() фрагмент кода, который заполняет два исходных
массива случайными числами, вызывает merge() и выводит содержимое полученного массива. Исходные массивы могут содержать
разное количество элементов. Ваш алгоритм должен сравнивать ключи исходных массивов и копировать меньший в приемный
массив. Также необходимо предусмотреть ситуацию, когда элементы в одном исходном массиве заканчиваются раньше, чем в
другом.
6. Добавьте в класс HighArray программы highArray.java (листинг 2.3) метод noDups(), удаляющий все дубликаты из массива.
Другими словами, если массив содержит три элемента с ключом 17, метод noDups() должен удалить два из них. Не
беспокойтесь о сохранении порядка элементов. Одно из возможных решений — сравнить каждый элемент со всеми остальными
элементами и заменить все дубликаты null (или другим значением, не встречающимся среди реальных ключей), после чего
удалить из массива все вхождения null. Конечно, размер массива при этом уменьшится